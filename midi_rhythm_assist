desc: A tool for practicing rhythm. Filters notes which are aligned to a groove.
//author: Eran Talmor
slider1:1<1,16,1{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16}>Beat Sub Divisions
slider2:0<-0.5,0.5,0.01>Swing
slider3:-0.2<-1,0,0.01>Early Filter %
slider4:0.2<0,1,0.01>Late Filter %

@init
noteOn = $x90;

maxhist = 100;
maxage = 30;
hits = 0;
misses = 0;

// Relative time to the beat
function getRelTime(offset) local(p)
(
  p = (beat_position + (offset * (tempo / 60) / srate));
  p - floor(p);
);

@slider
subdivisions = slider1 + 1;
swing = slider2;
early = slider3;
late = slider4;

historyTime = 0;
historyRelTime = historyTime + maxhist;
historyHits = historyRelTime + maxhist;
histidx = 0;

subdivisions = slider1 + 1;
vearly = maxhist*3;
vlate = vearly + subdivisions + 1;
vgrid = vlate + subdivisions + 1;

vearly[0] = 0;
vgrid[0] = 0;
vgrid[subdivisions] = 1;
vlate[subdivisions] = 1;

j=0;
loop(subdivisions+1,
  vgrid[j] = j/subdivisions + (j&(1+subdivisions)&1 ? swing/subdivisions);
  vearly[j] = max(0, vgrid[j] + early/2/subdivisions);
  vlate[j] = min(1, vgrid[j] + late/2/subdivisions);
  j+=1;
  swing_phase *= -1;
);

@block

function isHit(reltime) local(i result)
(
  i=0;
  result = 0;
  while(
     result |= (vearly[i] <= reltime) && (reltime <= vlate[i]);
     i += 1;
     !result && (i <= subdivisions)
  );
  result;
);

function addToHistory(reltime, hit)
(
     historyTime[histidx] = time_precise();
     historyRelTime[histidx] = reltime;
     historyHits[histidx] = hit;
     histidx += 1;
     (histidx >= maxhist) ? (histidx = 0);
);

while (midirecv(offset,msg1,msg2,msg3)) ( // REAPER 4.59+ syntax while()
   noteStatus = msg1 & $xF0;
   channel = msg1 & 0x0F;
   
   play_state && noteStatus==noteOn && msg3!=0 ? (
     note = msg2;
     reltime = getRelTime(offset);
     hit = isHit(reltime);
     hit ? (midisend(offset,msg1,note,msg3));
     addToHistory(reltime, hit);
   ) : (
     midisend(offset,msg1,msg2,msg3); // passthrough other events
   )
);

@gfx
function rgb(r,g,b) 
(
  gfx_r = r;
  gfx_g = g;
  gfx_b = b;
);

xmargin = 20;
ymargin = 40;
width = gfx_w-xmargin*2;
height = max(150, gfx_h-ymargin*2);
rgb(0.2, 0.2, 0.2); // grey
gfx_rect(xmargin, ymargin, width, height);

// Draw "grid" area
i=0;
loop(subdivisions+1,
  rgb(0, 0.4, 0);
  low = xmargin+vearly[i]*width;
  grid = xmargin+vgrid[i]*width;
  high = xmargin+vlate[i]*width;
  gfx_rect(low, ymargin, high-low, height);
  rgb(1,1,1); // white
  gfx_line(grid, ymargin, grid, ymargin + height); 
  i+=1;
);
gfx_line(gfx_w-xmargin, ymargin, gfx_w-xmargin, ymargin+height);

play_state ? (  
  // Draw history of notes played
  i=0;
  now = time_precise();
  loop(maxhist,
    birth = historyTime[i];
    birth != 0 ? (
      hit = historyHits[i];
      age = min(maxage, now - birth);
      ageRatio = sqrt(1/(1+age));
      hit > 0 ? rgb(0,ageRatio*ageRatio,0) : rgb(ageRatio,0,0);
      x = width * historyRelTime[i];
      y = age*20;
      y < height ? (gfx_circle(xmargin + x, ymargin+y, 8, 1));
      age == maxage ? (historyTime[i] = 0);
    );
    i += 1;
  );  

  // Draw vertical line position
  rgb(1,1,0);
  x = xmargin + width * getRelTime();
  gfx_line(x, ymargin, x, ymargin+height);
  
  previousTime = currentTime;
);
