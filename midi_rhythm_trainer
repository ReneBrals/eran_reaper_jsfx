desc: A tool for practicing rhythm. Filters notes which are aligned to a groove.
//author: Eran Talmor (C) 2021
slider1:4<1,16,1>Beats
slider2:8<1,128,1>Divisions
slider3:0<-0.5,0.5,0.01>Swing
slider4:0.5<1,100,0.1>Error Bound (%)
slider6:1<0,1,1{Off, On}>Auto Adjust Error Bound
slider7:5<1,15,1>Max Training Graph Minutes
@init
note_on = $x90;

max_hist = 200;
max_age = 60;
graph_start = 0;
graph_idx = 0;
hit_memory = 0.85;

// Relative time to the beat
function getRelTime(offset) local(p)
(
  p = (beat_position + (offset * (tempo / 60) / srate))/beats;
  p - floor(p);
);

function adjustGrid() local(j)
(
  j=0;
  loop(divisions+1,
    v_grid[j] = j/divisions + (j&(1+divisions)&1 ? swing/divisions);
    v_early[j] = max(0, v_grid[j] - error_bound/2/divisions);
    v_late[j] = min(1, v_grid[j] + error_bound/2/divisions);
    j+=1;
  );  
);

function adjust_error_bound(hit_rate) local(level)
(
  (hit_rate > 0.9) ? 
    ((error_bound < 0.2 ? level = 0.001 : error_bound <= 0.4 ? level = 0.005 : level = 0.01);
     (error_bound = max(0, error_bound - level)));
  slider4 = error_bound*100;
  adjustGrid();   
);

// returns: 0 == hit, -1 == early, 1 == late
function isHit(reltime) local(i, hit, min_late, min_early, delta_early, delta_late)
(
  i=0;
  hit = 0;
  min_late = 1;
  min_early = 1;
  while(
     delta_early = v_early[i] - reltime;
     delta_late = reltime - v_late[i];
     hit |= (delta_early <= 0) && (delta_late <= 0);
     delta_early > 0 ? (min_early = min(min_early, delta_early));
     delta_late > 0 ? (min_late = min(min_late, delta_late));
     i += 1;
     !hit && (i <= divisions)
  );
  hit ? 0 : (min_late > min_early ? -1 : 1); 
);

@slider
beats = slider1;
divisions = slider2;
divisions = divisions;
swing = slider3;
error_bound = slider4/100;
auto_adjust = slider6;
max_graph = 60*slider7;

v_history_time = 0;
v_history_rel_time = v_history_time + max_hist;
v_history_hits = v_history_rel_time + max_hist;
histidx = 0;

v_early = max_hist*3;
v_late = v_early + divisions + 1;
v_grid = v_late + divisions + 1;

v_early[0] = 0;
v_grid[0] = 0;
v_grid[divisions] = 1;
v_late[divisions] = 1;


v_graph_hit_rate = v_grid + divisions + 1;
v_graph_error_bound = v_graph_hit_rate + max_graph;

adjustGrid();

@block


function recordHistory(reltime, hit)
(
  v_history_time[histidx] = time_precise();
  v_history_rel_time[histidx] = reltime;
  v_history_hits[histidx] = hit;
  events_count = events_count * hit_memory + 1;
  hits_count = hits_count * hit_memory + (hit==0);
  hit_rate = hits_count/events_count;
  (auto_adjust) ? (adjust_error_bound(hit_rate));
  histidx += 1;
  (histidx >= max_hist) ? (histidx = 0);
);

function recordTraining()
(
  t = time();
  (t - graph_start > max_graph) ? (graph_start = t; graph_idx = 0);
  graph_idx = t - graph_start;
  v_graph_hit_rate[graph_idx] = hit_rate;
  v_graph_error_bound[graph_idx] = error_bound;
);

while (midirecv(offset,msg1,msg2,msg3)) ( // REAPER 4.59+ syntax while()
   noteStatus = msg1 & $xF0;
   channel = msg1 & 0x0F;
   
   play_state && noteStatus==note_on && msg3!=0 ? (
     note_count += 1;
     note = msg2;
     reltime = getRelTime(offset);
     hit = isHit(reltime);
     (hit == 0) ? (midisend(offset,msg1,note,msg3));
     recordHistory(reltime, hit);
   ) : (
     midisend(offset,msg1,msg2,msg3); // passthrough other events
   );
  
   play_state ? recordTraining();
);

@gfx
function rgb(r,g,b) 
(
  gfx_r = r;
  gfx_g = g;
  gfx_b = b;
);

function verticalDashedLine(x, y1, y2, dash, space) local(i, y)
(
  y = y1;
  dash = max(0, dash-1);
  loop ((y2-y1)/(dash + space),
    gfx_line(x,y, x, y+dash);
    y += dash+space);
);

function drawFrame(x,y,w,h)
(
  gfx_x = x;
  gfx_y = y;
  rgb(0.5,0.5,0.5);
  gfx_lineto(x+w,y);
  rgb(1,1,1);
  gfx_lineto(x+w,y+h);
  gfx_lineto(x,y+h);
  rgb(0.5,0.5,0.5);
  gfx_lineto(x,y);
);

xmargin = 20;
header_margin = 30;
footer_margin = 20;

gfx_x = xmargin;
gfx_y = 10;
rgb(1,1,1);
gfx_printf("Rhythm Grid:");

width = gfx_w-xmargin*2;
grid_height = max(150, (gfx_h - header_margin - footer_margin) / 2);
rgb(0.27, 0.27, 0.27); // grey
gfx_rect(xmargin, header_margin, width, grid_height);

// Draw "grid" area
i=0;
loop(divisions+1,
  rgb(0, 0.4, 0);
  low = xmargin+v_early[i]*width;
  grid = xmargin+v_grid[i]*width;
  high = xmargin+v_late[i]*width+1;
  gfx_rect(low, header_margin, high-low, grid_height);
  rgb(0.67, 0.67, 0.67); 
  verticalDashedLine(grid, header_margin, header_margin+grid_height, 1, 5);
  i+=1;
);

i=0;
loop(beats+1,
  rgb(1,1,1);
  grid = xmargin + i*width/beats;
  gfx_line(grid,header_margin, grid, header_margin + grid_height);
  i+=1;
);
  
drawFrame(xmargin, header_margin, width, grid_height);
 
play_state ? (  
  // Draw history of notes played
  i=0;
  now = time_precise();
  loop(max_hist,
    birth = v_history_time[i];
    birth != 0 ? (
      hit = v_history_hits[i];
      age = min(max_age, now - birth);
      age_brightness = 0.2 + 1/(0.8*(1+age));
      (hit == 0) ? rgb(0,age_brightness,0) : 
        (hit == 1) ? rgb(age_brightness,0,0) : rgb(0,0,age_brightness);
      x = width * v_history_rel_time[i];
      y = age*20;
      y < grid_height ? (gfx_circle(xmargin + x, header_margin+y, 8, 1));
      age == max_age ? (v_history_time[i] = 0);
    );
    i += 1;
  );
  
  // Draw vertical time line 
  rgb(1,1,0);
  x = xmargin + width * getRelTime();
  gfx_line(x, header_margin, x, header_margin+grid_height);  
);

// Draw Training graph
//-------------------
graph_top = header_margin + grid_height + 30;
graph_height = max(150, gfx_h - footer_margin - graph_top);

gfx_x = xmargin;
gfx_y = graph_top-20;
rgb(1,1,1);
gfx_printf("Training Graph (");
rgb(1,1,0);
gfx_printf("Hit Rate: %0.0f%%", hit_rate*100);
rgb(1,1,1);
gfx_printf(" , ");
rgb(0,1,1);
gfx_printf("error_bound: %0.0f%%", error_bound*100);
rgb(1,1,1);
gfx_printf(")");

rgb(0.27, 0.27, 0.4); // greyish purple
gfx_rect(xmargin, graph_top, width, graph_height);

graph_x_ratio = width/(max_graph-1);
i=0;
rgb(0.67, 0.67, 0.67); 
loop(max_graph/10,
  (i%60 == 0) ?
    gfx_line(xmargin + i*graph_x_ratio, graph_top, xmargin + i*graph_x_ratio, graph_top+graph_height)
  : verticalDashedLine(xmargin + i*graph_x_ratio, graph_top, graph_top+graph_height, 4, 5);
  i += 10;);
gfx_line(xmargin + width, graph_top, xmargin + width, graph_top+graph_height);

// Draw verical time line
rgb(1, 1, 1);
gfx_line(xmargin + graph_idx*graph_x_ratio, graph_top, xmargin + graph_idx*graph_x_ratio, graph_top + graph_height);

// hit rate
i=0;
rgb(1,1,0);
gfx_x = xmargin;
gfx_y = graph_top + graph_height*(1 - v_graph_hit_rate[0]);
loop(max_graph,
  hr = max(0, min(1, 1 - v_graph_hit_rate[i]));
  gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*hr);
  i+=1);

// error_bound
i=0;
rgb(0,1,1);
gfx_x = xmargin;
gfx_y = graph_top + graph_height*(1 - v_graph_error_bound[0]);
loop(max_graph,
  pr = max(0, min(1, 1 - v_graph_error_bound[i]));
  gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*pr);
  i+=1);

drawFrame(xmargin, graph_top, width, graph_height);
