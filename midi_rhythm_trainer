/*******************************************************************************
*  Copyright 2021, Eran Talmor                                                 *
*  This program is free software: you can redistribute it and/or modify        *
*  it under the terms of the GNU General Public License as published by        *
*  the Free Software Foundation, either version 3 of the License, or           *
*  (at your option) any later version.                                         *
*                                                                              *
*  This program is distributed in the hope that it will be useful,             *
*  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                *
*  GNU General Public License (http://www.gnu.org/licenses/)for more details.  *
*******************************************************************************/

desc: A tool for practicing rhythm. Filters notes which are aligned to a groove.
//author: Eran Talmor (C) 2021
slider1:4<1,16,1>Beats
slider2:8<1,128,1>Divisions1
slider3:0<0,128,1>Divisions2
slider4:0<0,128,1>Divisions3
slider5:0<0,128,1>Divisions4
slider6:0<-0.5,0.5,0.01>Swing (Div 1)
slider7:50<1,100,0.1>Error Bound (%)
slider8:1<0,1,1{Off, On}>Auto Adjust
slider9:5<1,15,1>Max Training Graph Minutes
slider10:0<0,4,1{Circles,Note Names,Note Numbers>Event Drawing Style
@init
note_on = $x90;

max_hist = 200;
max_age = 60;
graph_start = 0;
graph_idx = 0;
hit_memory = 0.85;

// Relative time to the beats
function getRelTime(offset) local(p)
(
  p = (beat_position + (offset * (tempo / 60) / srate))/beats;
  p - floor(p);
);

function getDivs(idx)
(
  idx == 0 ? div0 
  : idx == 1 ? div1 
  : idx == 2 ? div2 
  : div3;
);

function getGrid(divs, i, is_swing)
(
  i == 0 ? 0
  : i == divs ? 1
  : i/divs + (is_swing&i&(1+divs)&1 ? swing/max_divs);
);

function getEarly(divs, i, is_swing)
(
  i == 0 ? 0
  : max(0, getGrid(divs, i, is_swing) - error_bound/2/max_divs);
);

function getLate(divs, i, is_swing)
(
  i == divs ? 1
  : min(1, getGrid(divs, i, is_swing) + error_bound/2/max_divs);
);

function adjust_error_bound(hit_rate) local(level)
(
  (hit_rate > 0.9) ? 
    (level = (error_bound < 0.2 ? 0.001 : error_bound <= 0.3 ? 0.002 : error_bound <= 0.4 ?  0.005 : 0.01);
    (error_bound = max(0, error_bound - level)));
  slider7 = error_bound*100;
);

// returns: 0 == hit, -1 == early, 1 == late
function isHit(reltime, divIdx) local(i, hit, min_late, min_early, delta_early, delta_late, divs)
(
  i=0;
  hit = 0;
  min_late = 1;
  min_early = 1;
  divs = getDivs(divIdx);
  is_swing = (divIdx == 0);
  while(
    delta_early = getEarly(divs, i, is_swing) - reltime;
    delta_late = reltime - getLate(divs, i, is_swing);
    hit |= (delta_early <= 0) && (delta_late <= 0);
    delta_early > 0 ? (min_early = min(min_early, delta_early));
    delta_late > 0 ? (min_late = min(min_late, delta_late));
    i += 1;
    !hit && (i <= divs)
  );
  hit ? 0 : (min_late > min_early ? -1 : 1); 
);

function getClosestDivIdx(reltime, note) local(i, hit, min_late, min_early, delta_early, delta_late, delta, divs)
(
  min_delta = 1;
  min_idx = 0;
  idx = v_notes_last_div[note];
  loop(4,
    is_swing = (idx==0);
    divs = getDivs(idx);
    i=0;
    divs ?
    (while(
      delta = abs(reltime - getGrid(divs, i, is_swing));
      min_delta > delta ? (min_delta = delta; min_idx = idx); 
      i += 1;
      (i <= divs)
    ));
    idx = (idx+1)%4;
  );
  v_notes_last_div[note] = min_idx;
  min_idx;
);

@slider
beats = slider1;
div0 = slider2;
div1 = slider3;
div2 = slider4;
div3 = slider5;
swing = slider6;
error_bound = slider7/100;
auto_adjust = slider8;
max_graph = 60*slider9;
event_style = slider10;

non_zero_divisions = 1 + (div1 != 0) + (div2 != 0) + (div3 !=0);
max_divs = max(div0, max(div1, max(div2, div3)));

v_graph_hit_rate = 4;
v_graph_error_bound = v_graph_hit_rate + max_graph;

v_history_time = v_graph_error_bound + max_graph;
v_history_rel_time = v_history_time + max_hist;
v_history_hits = v_history_rel_time + max_hist;
v_history_div = v_history_hits + max_hist;
v_history_notes = v_history_div + max_hist;
v_notes_last_div = v_history_notes + max_hist;

histidx = 0;

@block

function recordHistory(reltime, hit, divIdx, note)
(
  v_history_time[histidx] = time_precise();
  v_history_rel_time[histidx] = reltime;
  v_history_hits[histidx] = hit;
  v_history_div[histidx] = divIdx;
  v_history_notes[histidx] = note;
  events_count = events_count * hit_memory + 1;
  hits_count = hits_count * hit_memory + (hit==0);
  hit_rate = hits_count/events_count;
  (auto_adjust) ? (adjust_error_bound(hit_rate));
  histidx = (histidx + 1) % max_hist;
);

function recordTraining()
(
  t = time();
  (t - graph_start > max_graph) ? (graph_start = t; graph_idx = 0);
  graph_idx = t - graph_start;
  v_graph_hit_rate[graph_idx] = hit_rate;
  v_graph_error_bound[graph_idx] = error_bound;
);

while (midirecv(offset,msg1,msg2,msg3)) ( // REAPER 4.59+ syntax while()
   noteStatus = msg1 & $xF0;
   channel = msg1 & 0x0F;
   
   play_state && noteStatus==note_on && msg3!=0 ? (
     note_count += 1;
     note = msg2;
     reltime = getRelTime(offset);
     divIdx = channel ? (channel - 1) : (getClosestDivIdx(reltime, note));
     hit = isHit(reltime, divIdx);
     (hit == 0) ? (midisend(offset,msg1,note,msg3));
     recordHistory(reltime, hit, divIdx, note);
   ) : (
     midisend(offset,msg1,msg2,msg3); // passthrough other events
   );
  
   play_state ? recordTraining();
);

@gfx
function rgb(r,g,b) 
(
  gfx_r = r;
  gfx_g = g;
  gfx_b = b;
);

function verticalDashedLine(x, y1, y2, dash, space) local(i, y)
(
  y = y1;
  dash = max(0, dash-1);
  loop ((y2-y1)/(dash + space),
    gfx_line(x,y, x, y+dash);
    y += dash+space);
);

function drawFrame(x,y,w,h)
(
  gfx_x = x;
  gfx_y = y;
  rgb(0.5,0.5,0.5);
  gfx_lineto(x+w,y);
  rgb(1,1,1);
  gfx_lineto(x+w,y+h);
  gfx_lineto(x,y+h);
  rgb(0.5,0.5,0.5);
  gfx_lineto(x,y);
);

function printCenter(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x-w/2;
  gfx_y = y;
  gfx_printf(str);
);

function noteName(note) local(names,sharps,nm,sh,str)
(
  names  = "CCDDEFFGGAAB";
  sharps = $x54A;
  nm = str_getchar(names, note%12);
  sh = ((1 << (note%12)) & sharps ? "#" : "");
  sprintf(str,"%c%s\%d", nm, sh, floor(note/12));
  str;
);

function drawEvent(x, y, note) local(str)
(
  (event_style == 0) ? gfx_circle(x, y, 6, 0)
: (event_style == 1) ? printCenter(x, y, noteName(note))  
: (event_style == 2) ? (sprintf(str, "%d", note);  printCenter(x, y, str));
);

function DrawGrid(idx, l,t,w,h) local(x,y, hit,now,low,grid,high,i,divs)
(
  rgb(0.27, 0.27, 0.27); // grey
  gfx_rect(l, t, w, h);

  // Draw "grid" area
  i=0;
  divs = getDivs(idx);
  is_swing = (idx == 0);
  loop(divs+1,
    rgb(0, 0.4, 0);
    divs = getDivs(idx);
    low = l+getEarly(divs,i,is_swing)*w;
    grid = l+getGrid(divs,i,is_swing)*w;
    high = l+getLate(divs,i,is_swing)*w+1;
    gfx_rect(low, t, high-low, h);
    rgb(0.67, 0.67, 0.67); 
    verticalDashedLine(grid, t, t+h, 1, 5);
    i+=1;
  );
  
  i=0;
  loop(beats+1,
    rgb(1,1,1);
    grid = l + i*w/beats;
    gfx_line(grid,t, grid,t+h);
    i+=1;
  );
  
  play_state ? (
    i=0;
    now = time_precise();
    loop(max_hist,
      birth = v_history_time[i];
      (birth != 0) && (v_history_div[i] == idx) ? (
        hit = v_history_hits[i];
        age = min(max_age, now - birth);
        age_brightness = 0.2 + 1/(0.8*(1+age));
        (hit == 0) ? rgb(0,age_brightness,0) : 
          (hit == 1) ? rgb(age_brightness,0,0) : rgb(0,0,age_brightness);
        x = w * v_history_rel_time[i];
        y = age*20;
        y < h ? (drawEvent(l+x,t+y, v_history_notes[i]));
        age == max_age ? (v_history_time[i] = 0);
      );
      i += 1;
    );
    
    // Draw vertical time line 
    rgb(1,1,0);
    x = l + w * getRelTime();
    gfx_line(x, t, x, t+h);
  );  
  
  drawFrame(l-1, t-1, w+2, h+2);
);

xmargin = 4;
header_margin = 20;
footer_margin = 4;

gfx_x = xmargin;
gfx_y = 5;
rgb(1,1,1);
gfx_printf("Rhythm Grid:");

width = gfx_w-xmargin*2;
total_grid_height = max(200, (gfx_h - header_margin - footer_margin) * 0.7);
total_grid_height -= total_grid_height % non_zero_divisions;

grid_margin = 6;
grid_height = total_grid_height / non_zero_divisions;
DrawGrid(0, xmargin, header_margin, width, grid_height-grid_margin);
y = header_margin + grid_height;
div1 ? (DrawGrid(1, xmargin, y, width, grid_height-grid_margin); y+=grid_height);
div2 ? (DrawGrid(2, xmargin, y, width, grid_height-grid_margin); y+=grid_height);
div3 ? (DrawGrid(3, xmargin, y, width, grid_height-grid_margin); y+=grid_height);

// Draw Training graph
//-------------------
graph_top = y + 20;
graph_height = max(80, gfx_h - footer_margin - graph_top);

gfx_x = xmargin;
gfx_y = graph_top-15;
rgb(1,1,1);
gfx_printf("Training Graph (");
rgb(1,1,0);
gfx_printf("Hit Rate: %0.0f%%", hit_rate*100);
rgb(1,1,1);
gfx_printf(" , ");
rgb(0,1,1);
gfx_printf("error_bound: %0.0f%%", error_bound*100);
rgb(1,1,1);
gfx_printf(")");

rgb(0.27, 0.27, 0.4); // greyish purple
gfx_rect(xmargin, graph_top, width, graph_height);

graph_x_ratio = width/(max_graph-1);
i=0;
rgb(0.67, 0.67, 0.67); 
loop(max_graph/10,
  (i%60 == 0) ?
    gfx_line(xmargin + i*graph_x_ratio, graph_top, xmargin + i*graph_x_ratio, graph_top+graph_height)
  : verticalDashedLine(xmargin + i*graph_x_ratio, graph_top, graph_top+graph_height, 4, 5);
  i += 10;);
gfx_line(xmargin + width, graph_top, xmargin + width, graph_top+graph_height);

// Draw verical time line
rgb(1, 1, 1);
gfx_line(xmargin + graph_idx*graph_x_ratio, graph_top, xmargin + graph_idx*graph_x_ratio, graph_top + graph_height);

// hit rate
i=0;
rgb(1,1,0);
gfx_x = xmargin;
gfx_y = graph_top + graph_height*(1 - v_graph_hit_rate[0]);
loop(max_graph,
  hr = max(0, min(1, 1 - v_graph_hit_rate[i]));
  gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*hr);
  i+=1);

// error_bound
i=0;
rgb(0,1,1);
gfx_x = xmargin;
gfx_y = graph_top + graph_height*(1 - v_graph_error_bound[0]);
loop(max_graph,
  pr = max(0, min(1, 1 - v_graph_error_bound[i]));
  gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*pr);
  i+=1);

drawFrame(xmargin-1, graph_top-1, width+2, graph_height+2);
