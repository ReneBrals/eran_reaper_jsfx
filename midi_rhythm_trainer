/*******************************************************************************
*  Copyright 2021, Eran Talmor                                                 *
*  This program is free software: you can redistribute it and/or modify        *
*  it under the terms of the GNU General Public License as published by        *
*  the Free Software Foundation, either version 3 of the License, or           *
*  (at your option) any later version.                                         *
*                                                                              *
*  This program is distributed in the hope that it will be useful,             *
*  but WITHOUT ANY WARRANTY; without even the implied warranty of              *
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                *
*  GNU General Public License (http://www.gnu.org/licenses/)for more details.  *
*******************************************************************************/

desc: MIDI Rhythm Trainer
//author: Eran Talmor (C) 2021
    
slider1:4<1,32,1>Beats
slider2:0<0,1,1,{Manual,Recording}>Rhythm Entry Mode
slider3:0<0,3,1{CH 1/4/9/13,CH 2/6/10/14,CH 3/7/11/15,CH 4/8/12/16}>Select Channel
slider4:8<0,64,1>Channel/Divisions
slider8:0<0,127,1{0: C0,1: C#0,2: D0,3: Eb0,4: E0,5: F0,6: F#0,7: G0,8: G#0,9: A0,10: Bb0,11: B0,12: C1,13: C#1,14: D1,15: Eb1,16: E1,17: F1,18: F#1,19: G1,20: G#1,21: A1,22: Bb1,23: B1,24: C2,25: C#2,26: D2,27: Eb2,28: E2,29: F2,30: F#2,31: G2,32: G#2,33: A2,34: Bb2,35: B2,36: C3,37: C#3,38: D3,39: Eb3,40: E3,41: F3,42: F#3,43: G3,44: G#3,45: A3,46: Bb3,47: B3,48: C4,49: C#4,50: D4,51: Eb4,52: E4,53: F4,54: F#4,55: G4,56: G#4,57: A4,58: Bb4,59: B4,60: C5,61: C#5,62: D5,63: Eb5,64: E5,65: F5,66: F#5,67: G5,68: G#5,69: A5,70: Bb5,71: B5,72: C6,73: C#6,74: D6,75: Eb6,76: E6,77: F6,78: F#6,79: G6,80: G#6,81: A6,82: Bb6,83: B6,84: C7,85: C#7,86: D7,87: Eb7,88: E7,89: F7,90: F#7,91: G7,92: G#7,93: A7,94: Bb7,95: B7,96: C8,97: C#8,98: D8,99: Eb8,100: E8,101: F8,102: F#8,103: G8,104: G#8,105: A8,106: Bb8,107: B8,108: C9,109: C#9,110: D9,111: Eb9,112: E9,113: F9,114: F#9,115: G9,116: G#9,117: A9,118: Bb9,119: B9,120: C10,121: C#10,122: D10,123: Eb10,124: E10,125: F10,126: F#10,127: G10}>Channel/Click/Note
slider10:50<1,100,0.1>Error Bound (%)
slider11:1<0,1,1{Off,On}>Auto Shrink Error Bound
slider12:0<0,4,1{Circles,Note Names,Note Numbers>Event Drawing Style

// Hidden sliders per channel
slider20:8<1,64,1>-Divisions1
slider21:0<-0.5,0.5,0.01>-Swing1
slider22:0<0,1,0.01>-Phase1
slider23:0<0,1,1>-Click1
slider24:60<0,127,1>-ClickNote1
slider25:60<0,127,1>-ClickVel1

slider30:0<0,64,1>-Divisions2
slider31:0<-0.5,0.5,0.01>-Swing2
slider32:0<0,1,0.01>-Phase2
slider33:0<0,1,1>-Click2
slider34:62<0,127,1>-ClickNote2
slider35:60<0,127,1>-ClickVel2

slider40:0<0,64,1>-Divisions3
slider41:0<-0.5,0.5,0.01>-Swing3
slider42:0<0,1,0.01>-Phase3
slider43:0<0,1,1>-Click3
slider44:64<0,127,1>-ClickNote3
slider45:60<0,127,1>-ClickVel3

slider50:0<0,64,1>-Divisions4
slider51:0<-0.5,0.5,0.01>-Swing4
slider52:0<0,1,0.01>-Phase4
slider53:0<0,1,1>-Click4
slider54:65<0,127,1>-ClickNote4
slider55:60<0,127,1>-ClickVel4

@init
note_on = $x90;

control_phase = 1;
control_swing = 2;
control_button_div_up = 3;
control_button_div_down = 4;
control_button_click = 5;
control_button_vel_up = 6;
control_button_vel_down = 7;


hist_idx = 0;
max_hist = 200;
max_age = 60;
max_graph = 10*60;
graph_start = 0;
graph_idx = 0;
hit_memory = 0.85;
enable_recording = 1;
max_recorded_divs = 1;

prev_select = -1;

v_history_time = 4; 
v_history_rel_time = v_history_time + max_hist;
v_history_hits = v_history_rel_time + max_hist;
v_history_chan = v_history_hits + max_hist;
v_history_notes = v_history_chan + max_hist;
v_play_indices = v_history_notes + max_hist;
v_play_timers = v_play_indices + 4;
v_play_off_timers = v_play_timers + 4;
v_rec_indices = v_play_off_timers + 4;
v_rec = v_rec_indices + 4;
v_graph_hit_rate = v_rec + 4*max_hist;
v_graph_error_bound = v_graph_hit_rate + max_graph;

function resetPlay() local(i)
(
  i=0;
  while (i<4) (
    (v_play_timers[i] > 0 ? v_play_timers[i] = -1;);
    v_play_indices[i] = 0; 
    i += 1;
  )
);

resetPlay();

// Relative time to the beats
function getRelTime(offset) local(p)
(
  p = (beat_position + (offset * (tempo / 60) / srate))/beats;
  p - floor(p);
);

function recordRecording(reltime, chan) local(i)
(
  v_rec[chan*max_hist + v_rec_indices[chan]] = reltime;
  v_rec_indices[chan] += 1;
  max_recorded_divs = max(max_recorded_divs, v_rec_indices[chan]);
);

function getDivs(idx)
( 
  (entry_mode == 1) ? v_rec_indices[idx]
  : idx == 0 ? div0 
  : idx == 1 ? div1 
  : idx == 2 ? div2
  : div3;
);

function setDivs(chan, value)
(
  (entry_mode == 1) ? 0
  : chan == 0 ? (slider20 = value; slider_automate(slider20); div0=max(1,min(64,value)))
  : chan == 1 ? (slider30 = value; slider_automate(slider30); div1=max(1,min(64,value)))
  : chan == 2 ? (slider40 = value; slider_automate(slider40); div2=max(1,min(64,value)))
  : (slider50 = value; slider_automate(slider50); div3=max(1,min(64,value)));
  max_divs = max(div0, max(div1, max(div2, div3)));
  resetPlay();
);

function getSwing(idx)
( 
  (entry_mode == 1) ? 0
  : idx == 0 ? swing0 
  : idx == 1 ? swing1 
  : idx == 2 ? swing2
  : swing3;
);

function setSwing(chan, value)
(
  ((entry_mode == 1) ? 0
  : chan == 0 ? (slider21 = value; slider_automate(slider21); swing0=value)
  : chan == 1 ? (slider31 = value; slider_automate(slider31); swing1=value)
  : chan == 2 ? (slider41 = value; slider_automate(slider41); swing2=value)
  : (slider51 = value; slider_automate(slider51); swing3=value););
  
);

function getPhase(idx)
( 
  (entry_mode == 1) ? 0
  : idx == 0 ? phase0 
  : idx == 1 ? phase1 
  : idx == 2 ? phase2
  : phase3;
);

function setPhase(chan, value)
(
  (entry_mode == 1) ? 0
  : chan == 0 ? (slider22 = value; slider_automate(slider22); phase0=value)
  : chan == 1 ? (slider32 = value; slider_automate(slider32); phase1=value)
  : chan == 2 ? (slider42 = value; slider_automate(slider42); phase2=value)
  : (slider52 = value; slider_automate(slider52); phase3=value)
);

function getClick(idx)
(
  idx == 0 ? click0 
  : idx == 1 ? click1 
  : idx == 2 ? click2
  : click3;
);

function setClick(chan, value)
(
  chan == 0 ? (slider23 = value; slider_automate(slider23); click0=max(0,min(1,value)))
  : chan == 1 ? (slider33 = value; slider_automate(slider33); click1=max(0,min(1,value)))
  : chan == 2 ? (slider43 = value; slider_automate(slider43); click2=max(0,min(1,value)))
  : (slider53 = value; slider_automate(slider53); click3=max(0,min(1,value)));
);

function getClickNote(idx)
(
  idx == 0 ? click_note0 
  : idx == 1 ? click_note1 
  : idx == 2 ? click_note2
  : click_note3;
);

function getClickVel(idx)
(
  idx == 0 ? click_vel0 
  : idx == 1 ? click_vel1 
  : idx == 2 ? click_vel2
  : click_note3;
);

function setClickVel(chan, value)
(
  chan == 0 ? (slider25 = value; click_vel0 = max(0, min(127, value)))
  : chan == 1 ? (slider35 = value; click_vel1 = max(0, min(127, value)))
  : chan == 2 ? (slider45 = value; click_vel2 = max(0, min(127, value)))
  : chan == 3 ? (slider45 = value; click_vel3 = max(0, min(127, value)));
);

function isRecording()
(
  play_state && enable_recording && (entry_mode == 1) && ((beat_position) < beats)
);

function getGridRaw(chan, divs, i)
(
  (entry_mode == 1) ? v_rec[max_hist*chan + i]
  : (i + (i&1 ? getSwing(chan)) + getPhase(chan))/divs;
);

function getGrid(chan, divs, i) local(r)
(
  r = getGridRaw(chan, divs, (i+divs)%divs);
  (i<0) ? r-1 : (i>=divs) ? r+floor(i/divs) : r;
);

function getErrorRange()
(
  (entry_mode == 1) ? error_bound/max_recorded_divs : error_bound/max_divs;
);

function getEarly(chan, divs, i)
(
  max(0, getGrid(chan, divs, i) - getErrorRange()/2);
);

function getLate(chan, divs, i)
(
  min(1, getGrid(chan, divs, i) + getErrorRange()/2);
);

function adjust_error_bound(hit_rate) local(level)
(
  (hit_rate > 0.9) ? 
    (level = (error_bound < 0.2 ? 0.001 : error_bound <= 0.3 ? 0.002 : error_bound <= 0.4 ?  0.005 : 0.01);
    (error_bound = max(0, error_bound - level)));
  slider7 = error_bound*100;
);

// returns: 0 == hit, -1 == early, 1 == late
function isHit(reltime, chan) local(i, hit, min_late, min_early, delta_early, delta_late, divs)
(
  i=0;
  hit = 0;
  min_late = 1;
  min_early = 1;
  divs = getDivs(chan);
  while(
    delta_early = getEarly(chan, divs, i) - reltime;
    delta_late = reltime - getLate(chan, divs, i);
    hit |= (delta_early <= 0) && (delta_late <= 0);
    delta_early > 0 ? (min_early = min(min_early, delta_early));
    delta_late > 0 ? (min_late = min(min_late, delta_late));
    i += 1;
    !hit && (i <= divs)
  );
  hit ? 0 : (min_late > min_early ? -1 : 1); 
);


@slider
beats = slider1;
entry_mode = slider2;

error_bound = slider10/100;
auto_shrink = slider11;
event_style = slider12;

select = slider3;

select != prev_select ?
  ( select == 0 ? (slider4 = slider20; slider8 = slider24)
  : select == 1 ? (slider4 = slider30; slider8 = slider34)
  : select == 2 ? (slider4 = slider40; slider8 = slider44)
  : select == 3 ? (slider4 = slider50; slider8 = slider54))
  
: (
  (slider4 != prev_slider4 ?
    ( select == 0 ? slider20 = max(1, slider4)
    : select == 1 ? slider30 = slider4
    : select == 2 ? slider40 = slider4
    : select == 3 ? slider50 = slider4));
  (slider8 != prev_slider8 ?
    ( select == 0 ? slider24 = slider8
    : select == 1 ? slider34 = slider8
    : select == 2 ? slider44 = slider8
    : select == 3 ? slider54 = slider8));
);

prev_select = select;

prev_slider4 = slider4;
prev_slider8 = slider8;

div0 = slider20;
swing0 = slider21;
phase0 = slider22;
click0 = slider23;
click_note0 = slider24;
click_vel0 = slider25;

div1 = slider30;
swing1 = slider31;
phase1 = slider32;
click1 = slider33;
click_note1 = slider34;
click_vel1 = slider35;

div2 = slider40;
swing2 = slider41;
phase2 = slider42;
click2 = slider43;
click_note2 = slider44;
click_vel2 = slider45;

div3 = slider50;
swing3 = slider51;
phase3 = slider52;
click3 = slider53;
click_note3 = slider54;
click_vel3 = slider55;

max_divs = max(div0, max(div1, max(div2, div3)));

resetPlay();

@block

function playGrid(chan, reset) local(sp_per_beat, sp_now, divs, sp_grid)
(
  (v_play_off_timers[chan] < samplesblock) ? (
    midisend(max(0, v_play_off_timers[chan]), $x90, getClickNote(chan), 0);
    v_play_off_timers[chan] = 1000000;
  );
  
  // find next "grid line" such that timer will be >= sampleblock
  (v_play_timers[chan] < samplesblock) ? (
    (v_play_timers[chan] >= 0 ? midisend(max(0, v_play_timers[chan]), $x90, getClickNote(chan), getClickVel(chan)));
    sp_per_beat = srate * 60 / tempo;
    sp_now = floor(0.001 + beat_position * sp_per_beat);
    divs = getDivs(chan);
    while (v_play_timers[chan] < samplesblock) (
      v_play_indices[chan] += 1;
      sp_grid = floor(0.001 + 1 * getGrid(chan, divs, v_play_indices[chan]) * sp_per_beat * beats);
      v_play_timers[chan] = sp_grid - sp_now;
    );
    v_play_off_timers[chan] = timer0 * 0.1;
  );
  
  v_play_timers[chan] -= samplesblock;
  v_play_off_timers[chan] -= samplesblock;
);

function recordHistory(reltime, hit, chan, note)
(
  enable_recording = 0;
  rec_idx = 0;
  v_history_time[hist_idx] = time_precise();
  v_history_rel_time[hist_idx] = reltime;
  v_history_hits[hist_idx] = hit;
  v_history_chan[hist_idx] = chan;
  v_history_notes[hist_idx] = note;
  events_count = events_count * hit_memory + 1;
  hits_count = hits_count * hit_memory + (hit==0);
  hit_rate = hits_count/events_count;
  (auto_shrink) ? (adjust_error_bound(hit_rate));
  hist_idx = (hist_idx + 1) % max_hist;
);

function recordTraining() local(t)
(
  t = time();
  (t - graph_start > max_graph) ? (graph_start = t; graph_idx = 0);
  graph_idx = t - graph_start;
  v_graph_hit_rate[graph_idx] = hit_rate;
  v_graph_error_bound[graph_idx] = error_bound;
);

play_state ? (
  getClick(0) ? playGrid(0, 0);
  getClick(1) && div1 ? playGrid(1, 1);
  getClick(2) && div2 ? playGrid(2, 1);
  getClick(3) && div3 ? playGrid(3, 1);
);

while (midirecv(offset,msg1,msg2,msg3)) ( // REAPER 4.59+ syntax w while()
   noteStatus = msg1 & $xF0;
   channel = msg1 & 0x0F;
   
   play_state && noteStatus==note_on && msg3!=0 ? (
     note_count += 1;
     note = msg2;
     reltime = getRelTime(offset);
     chan = channel % 4;
     hit = isHit(reltime, chan);
     isrec = isRecording();
     (isrec || (hit == 0)) ? (midisend(offset,msg1,note,msg3));
     isrec ? recordRecording(reltime, chan) : recordHistory(reltime, hit, chan, note);
   ) : (
     enable_recording = 1;
     midisend(offset,msg1,msg2,msg3); // passthrough other events
   );
  
   play_state ? recordTraining();
);

prev_play_state = play_state;

@gfx
#value_edit = "";

function isLButtonRelease()
(
  (1 ~ mouse_cap) & prev_mouse_cap & 1;
);

function rgb(r,g,b) 
(
  gfx_r = r;
  gfx_g = g;
  gfx_b = b;
);

function verticalDashedLine(x, y1, y2, dash, space) local(i, y)
(
  y = y1;
  dash = max(0, dash-1);
  loop ((y2-y1)/(dash + space),
    gfx_line(x,y, x, y+dash);
    y += dash+space);
);

function drawFrame(x,y,w,h)
(
  gfx_x = x;
  gfx_y = y;
  rgb(0.5,0.5,0.5);
  gfx_lineto(x+w,y);
  rgb(1,1,1);
  gfx_lineto(x+w,y+h);
  gfx_lineto(x,y+h);
  rgb(0.5,0.5,0.5);
  gfx_lineto(x,y);
);

function printCenter(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x-w/2;
  gfx_y = y-h/2;
  gfx_printf(str);
);

function printValueEdit(x,y) local(w,h, margin)
(
  (strlen(#value_edit) > 0) ? 
  (
    rgb(1,1,1);
    gfx_setfont(1, "Arial", 24);
    gfx_measurestr(#value_edit,w,h);
    gfx_a=0.16;
    margin=4;
    gfx_rect(x-w/2-margin, y-h/2-margin, w+margin*2, h+margin*2);
    gfx_a=1;
    gfx_x = x-w/2;
    gfx_y = y-h/2;
    rgb(1,1,1);
    gfx_printf(#value_edit);
    #value_edit = "";
  );
);


function printCenterUnderline(x,y,str)
(
  gfx_measurestr(str,w,h);
  gfx_x = x-w/2;
  gfx_y = y;
  gfx_printf(str);
  gfx_line(x-w/2,y+h,x+w/2,y+h);
  gfx_line(x,y+h,x,y+h+2);
);

function printBottomLeft(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x-w;
  gfx_y = y-h;
  gfx_printf(str);
);

function printBottomRight(x,y,str) local(w,h)
(
  gfx_measurestr(str,w,h);
  gfx_x = x;
  gfx_y = y-h;
  gfx_printf(str);
);

function noteName(note) local(names,sharps,nm,sh,str)
(
  names  = "CCDDEFFGGAAB";
  sharps = $x54A;
  nm = str_getchar(names, note%12);
  sh = ((1 << (note%12)) & sharps ? "#" : "");
  sprintf(str,"%c%s\%d", nm, sh, floor(note/12));
  str;
);

function drawEvent(x, y, note, is_hit) local(str)
(
  (event_style == 0) ? (is_hit ? gfx_circle(x, y, 6, 1, 1) : (gfx_circle(x, y, 6, 0,1); gfx_circle(x, y, 5, 0,1)))
: (event_style == 1) ? printCenterUnderline(x, y, noteName(note))  
: (event_style == 2) ? (sprintf(str, "%d", note);  printCenterUnderline(x, y, str));
);

function isMouseInRect(l,t,w,h)
(
  mouse_x >= l && mouse_x <= l+w && mouse_y >= t && mouse_y <= t+h;
);

function controlId(chan, control)
(
  (chan + 1)*100 + control;
);

function dragPhase(chan,focus_control,divs, l,t,w,h) local(dx, orig_value, orig_x, resolution, ctrl_id)
(
  ctrl_id = controlId(chan, control_phase);
  
  active_control == ctrl_id ? (
      dx = orig_value + (mouse_x - orig_x)*divs/w/2;
      resolution = mouse_cap & 4 ? 12 : 360;  
      dx = floor(dx*resolution + 0.5) / resolution;
      setPhase(chan, max(0, min(1, dx)));
    ) 
  : active_control == 0 && focus_control == ctrl_id ? (
      active_control = focus_control;
      orig_value = getPhase(chan);
      orig_x = mouse_x;
  );
  
  (active_control == ctrl_id || focus_control == ctrl_id) ? (
    sprintf(#value_edit, "Phase: %0.2f", getPhase(chan));
    //printValueEdit(l+w/2, t+h/2, #value_edit);
  );
);

function dragSwing(chan,focus_control,divs, l,t,w,h) local(dx, orig_value, orig_x, resolution, ctrl_id)
(
  ctrl_id = controlId(chan, control_swing);
  
  active_control == ctrl_id ? (
      dx = orig_value + (mouse_x - orig_x)*divs/w/2;
      resolution = mouse_cap & 4 ? 12 : 360;  
      dx = floor(dx*resolution + 0.5) / resolution;
      setSwing(chan, max(-0.5, min(0.5, dx)));
    ) 
  : active_control == 0 && focus_control == ctrl_id ? (
      active_control = focus_control;
      orig_value = getSwing(chan);
      orig_x = mouse_x;
  );
  
  (active_control == ctrl_id || focus_control == ctrl_id) ? (
    sprintf(#value_edit, "Swing: %0.2f", getSwing(chan));
    //printValueEdit(l+w/2, t+h/2, str);
  );
);

function emptyRect(l,t,w,h)
(
  gfx_x = l;
  gfx_y = t;
  gfx_lineto(l+w,t);
  gfx_lineto(l+w,t+h);
  gfx_lineto(l,t+h);
  gfx_lineto(l,t);
);

function drawButton(chan, id, l, t, w, h, str, state) local(focus, button_id, focus_brightness, state_brightness, press_brighness, delta)
(
  button_id = controlId(chan, id);
  !active_control && isMouseInRect(l,t,w,h) && mouse_cap & 1 ? active_control = button_id;
  focus = (!active_control || active_control == button_id) && isMouseInRect(l,t,w,h);
  focus_brightness = 0.1 * focus;
  state_brightness = 0.5 * state;
  press_brightness = 0.2 * focus * (mouse_cap & 1);
  delta = focus_brightness - press_brightness;
  rgb(delta, delta+state_brightness, delta+state_brightness);
  gfx_rect(l,t,w,h);
  rgb(0.5+delta, 0.5+delta, 0.5+delta);
  emptyRect(l,t,w,h);
  rgb(1,1,1);
  rgb(0.7+delta, 0.7+delta, 0.7+delta);
  printCenter(l+w/2, t+h/2, str);
  focus;
);

function drawToolBar(chan, l, t, w, h) local(release, f1, f2, f3, f4, f5, button_top)
(
  gfx_setfont(1, "Arial", 14);
  release = isLButtonRelease();
  mouse_wheel_dir = mouse_wheel > 0 ? 1 : mouse_wheel < 0 ? -1 : 0;
  button_top = t;
  f1 = drawButton(chan, control_div_up, l+4, button_top, w-4, w-4, "+", 0);
  button_top += w;
  f2 = drawButton(chan, control_div_down, l+4, button_top, w-4, w-4, "-", 0);
  button_top += w;
  button_top += 4;
  f5 = drawButton(chan, control_click, l+4, button_top, w-4, w-4, "c", getClick(chan));
  button_top += w;
  f3 = drawButton(chan, control_vel_up, l+4, button_top, w-4, w-4, "v+", 0);
  button_top += w;
  f4 = drawButton(chan, control_vel_down, l+4, button_top, w-4, w-4, "v-", 0);
  button_top += w;
  release && f1 ? setDivs(chan, getDivs(chan)+1); 
  release && f2 ? setDivs(chan, getDivs(chan)-1); 
  release && f3 ? setClickVel(chan, floor(getClickVel(chan)/4)*4+4); 
  release && f4 ? setClickVel(chan, floor(getClickVel(chan)/4)*4-4);
  release && f5 ? setClick(chan, !getClick(chan)); 
  f1 || f2 ? sprintf(#value_edit, "Divisions: %d", getDivs(chan));
  f3 || f4 ? sprintf(#value_edit, "Click Velocity: %d", getClickVel(chan));
  f1 || f2 && mouse_wheel_dir ? setDivs(chan, getDivs(chan)+mouse_wheel_dir);
  f3 || f4 && mouse_wheel_dir ? setClickVel(chan, getClickVel(chan)+mouse_wheel_dir);
  f5 ? sprintf(#value_edit, "Click: %s", getClick(chan) ? "On" : "Off");
);

function DrawGrid(chan, l,t,w,h) local(x,y, hit,now,low,grid,high,i,divs, focus_control)
(
  toolbar_width = 20;
  w -= toolbar_width;
  drawToolBar(chan, l+w,t,toolbar_width,h);
  
  focus_control = 0;
  
  rgb(0.27, 0.27, 0.27);
  gfx_rect(l, t, isRecording() ? w * getRelTime() : w, h);

  // Draw "grid" area
  divs = getDivs(chan);
    
  !isRecording() ? (
    // Draw green areas
    rgb(0, 0.4, 0);
    i=-1;
    loop(divs+2,
      low = l+getEarly(chan, divs, i)*w;
      high = l+getLate(chan, divs, i)*w+1;
      gfx_rect(low, t, high-low, h);
      i+=1;
    );
  );
  
  // Draw dashed rhythm lines
  i=0;
  ctrl_phase_id = controlId(chan, control_phase);
  ctrl_swing_id = controlId(chan, control_swing);
  loop(divs, 
    grid = l+getGrid(chan, divs, i)*w;
    ((i+1)%2) && ((!active_control && isMouseInRect(grid-8, t, 16, h)) || (active_control == ctrl_phase_id)) ? (
      focus_control = ctrl_phase_id;
      rgb(0,0.5,0.5);
      gfx_rect(grid-6, t, 12, h);
    );
    (i%2) && ((!active_control && isMouseInRect(grid-8, t, 16, h)) || (active_control == ctrl_swing_id)) ? (
      focus_control = ctrl_swing_id;
      rgb(0.5,0,1);
      gfx_rect(grid-6, t, 12, h);
    );
    rgb(0.67, 0.67, 0.67);
    verticalDashedLine(grid, t, t+h, 1, 5);
    sprintf(str, "%d", i+1);
    gfx_setfont(1, "Arial", 12);
    printBottomRight(grid+3,t+h,str);
    i+=1;
  );
    
  // Draw beat marks
  rgb(0.8, 0.8, 0.8);
  (chan == 0) ? gfx_setfont(1, "Arial", 12);
  i=0;
  loop(beats,
    grid = l + i*w/beats;
    gfx_line(grid,t, grid,t+h*0.1);
    gfx_line(grid,t+h*0.9, grid,t+h);
    (chan == 0) ? (
      gfx_x = grid + 3;
      gfx_y = t + 1;
      gfx_printf("%d",i+1);
    );
    i+=1;
  );
  gfx_setfont(1, "Arial", 14);
  
  play_state ? (
    i=0;
    now = time_precise();
    loop(max_hist,
      birth = v_history_time[i];
      (birth != 0) && (v_history_chan[i] == chan) ? (
        hit = v_history_hits[i];
        age = min(max_age, now - birth);
        age_brightness = 0.2 + 1/(0.8*(1+age));
        (hit == 0) ? rgb(0,age_brightness,0) : 
          (hit == 1) ? rgb(age_brightness,0,0) : rgb(0,0,age_brightness);
        x = w * v_history_rel_time[i];
        y = age*20;
        y < h ? (drawEvent(l+x,t+y, v_history_notes[i], (hit == 0)));
        age == max_age ? (v_history_time[i] = 0);
      );
      i += 1;
    );
    
    // Draw vertical time line 
    rgb(1,1,0);
    x = l + w * getRelTime();
    gfx_line(x, t, x, t+h);
  );  
  
  rgb(1,0,0);
  gfx_setfont(1, "Arial", 48);
  isRecording() ? (printCenter(w/2, h/2, "RECORDING"));
  gfx_setfont(0);  
 
  dragPhase(chan,focus_control,divs, l, t, w, h);
  dragSwing(chan,focus_control,divs, l, t, w, h);
  
  printValueEdit(l+w/2, t+h/2);
  
  drawFrame(l-1, t-1, w+2, h+2);
);

xmargin = 4;
header_margin = 20;
footer_margin = 4;

gfx_x = xmargin;
gfx_y = 1;
rgb(1,1,1);
gfx_setfont(1, "Arial", 15);
gfx_printf("Rhythm Grid:");

width = gfx_w-xmargin*2;
total_grid_height = max(200, (gfx_h - header_margin - footer_margin) * 0.7);
non_zero_divisions = 1 + (getDivs(1) != 0) + (getDivs(2) != 0) + (getDivs(3) !=0);
total_grid_height -= total_grid_height % non_zero_divisions;

grid_margin = 6;
grid_height = total_grid_height / non_zero_divisions;
DrawGrid(0, xmargin, header_margin, width, grid_height-grid_margin);
y = header_margin + grid_height;
getDivs(1) ? (DrawGrid(1, xmargin, y, width, grid_height-grid_margin); y+=grid_height);
getDivs(2) ? (DrawGrid(2, xmargin, y, width, grid_height-grid_margin); y+=grid_height);
getDivs(3) ? (DrawGrid(3, xmargin, y, width, grid_height-grid_margin); y+=grid_height);

// Draw Training graph
//-------------------
graph_top = y + 20;
graph_height = max(80, gfx_h - footer_margin - graph_top);

gfx_x = xmargin;
gfx_y = graph_top-20;
gfx_setfont(1, "Arial", 15);
rgb(1,1,1);
gfx_printf("Training Graph (");
rgb(1,1,0);
gfx_printf("Hit Rate: %0.0f%%", hit_rate*100);
rgb(1,1,1);
gfx_printf(", ");
rgb(0,1,1);
gfx_printf("Error Bound: %0.0f%%", error_bound*100);
rgb(1,1,1);
gfx_printf(")");

rgb(0.27, 0.27, 0.4); // greyish purple
gfx_rect(xmargin, graph_top, width, graph_height);

gfx_setfont(1, "Arial", 12);
graph_x_ratio = width/(max_graph-1);
i=0;
rgb(0.67, 0.67, 0.67); 
loop(max_graph/10,
  (i%60 == 0) ?
    (gfx_line(xmargin + i*graph_x_ratio, graph_top, xmargin + i*graph_x_ratio, graph_top+graph_height);
    sprintf(str, "%2d:00", 1+i/60);
    printBottomLeft(xmargin + (i+60)*graph_x_ratio-1, graph_top + graph_height, str))
  : verticalDashedLine(xmargin + i*graph_x_ratio, graph_top, graph_top+graph_height, 4, 5);
  i += 10;);
gfx_line(xmargin + width, graph_top, xmargin + width, graph_top+graph_height);

// Draw verical time line
rgb(1, 1, 1);
gfx_line(xmargin + graph_idx*graph_x_ratio, graph_top, xmargin + graph_idx*graph_x_ratio, graph_top + graph_height);

// hit rate
i=0;
rgb(1,1,0);
gfx_x = xmargin;
gfx_y = graph_top + graph_height*(1 - v_graph_hit_rate[0]);
loop(max_graph,
  hr = max(0, min(1, 1 - v_graph_hit_rate[i]));
  gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*hr);
  i+=1);

// error_bound
i=0;
rgb(0,1,1);
gfx_x = xmargin;
gfx_y = graph_top + graph_height*(1 - v_graph_error_bound[0]);
loop(max_graph,
  pr = max(0, min(1, 1 - v_graph_error_bound[i]));
  gfx_lineto(xmargin + i*graph_x_ratio, graph_top + graph_height*pr);
  i+=1);

drawFrame(xmargin-1, graph_top-1, width+2, graph_height+2);

prev_mouse_cap = mouse_cap;
mouse_wheel = 0;
mouse_cap & 1 == 0 ? active_control = 0;
